'''
Initialize should be the first skill evoked in the program to
configure all machines and jog cobot to initial position.
'''

from ...data_nodes.skill_argument import SkillArgument
from ..skill import Skill
from ..hierarchical import Hierarchical
from ..primitives import MoveUnplanned, MachineInitialize, Gripper


class Initialize(Skill):

    '''
    Data structure methods
    '''

    @classmethod
    def display_name(cls):
        return 'Initialize'

    @classmethod
    def type_string(cls, trailing_delim=True):
        return 'initialize' + ('.' if trailing_delim else '')

    @classmethod
    def full_type_string(cls):
        return Skill.full_type_string() + cls.type_string()

    def __init__(self, primitives=None, arguments=None, parameters=None, type='', 
                 name=None, uuid=None, parent=None, append_type=True, 
                 editable=False, deleteable=False, description=''):

        loc_uuid_arg = None
        machine_uuids_arg = None
        if arguments != None:
            for a in arguments:
                if a.name == 'home_location_uuid':
                    loc_uuid_arg = a
                elif a.name == 'machine_uuids':
                    machine_uuids_arg = a
            
            if loc_uuid_arg == None:
                loc_uuid_arg = SkillArgument(parameter_key='location_uuid', name='home_location_uuid')
                arguments.append(loc_uuid_arg)
            
            if machine_uuids_arg == None:
                machine_uuids_arg = SkillArgument(parameter_key='machine_uuid', name='machine_uuids', description='Initialize performs expansion on the list for each primitive')
                arguments.append(machine_uuids_arg)

        else:
            loc_uuid_arg = SkillArgument(parameter_key='location_uuid', name='home_location_uuid')
            machine_uuids_arg = SkillArgument(parameter_key='machine_uuid', name='machine_uuids', description='Initialize performs expansion on the list for each primitive')
            arguments = [loc_uuid_arg, machine_uuids_arg]

        if primitives == None:
            primitives = [
                MachineInitialize(machine_uuids_arg.temporary_value, editable=editable, deleteable=False),
                Gripper(position=0, editable=editable, deleteable=False),
                MoveUnplanned(loc_uuid_arg.temporary_value,True, editable=editable, deleteable=False)
            ]
        else:
            primitives[0].machine_uuid = machine_uuids_arg.temporary_value
            primitives[2].location_uuid = loc_uuid_arg.temporary_value

        if name == None:
            name = 'Initialize'

        super(Initialize,self).__init__(
            type=Initialize.type_string() + type if append_type else type,
            name=name,
            uuid=uuid,
            parent=parent,
            append_type=append_type,
            editable=editable,
            deleteable=deleteable,
            description=description,
            parameters=parameters,
            primitives=primitives,
            arguments=arguments)

    '''
    Execution methods
    '''

    def symbolic_execution(self, hooks):
        next = super(Initialize,self).symbolic_execution(hooks)

        # Since we are initializing state, the ambigous movement is expected and does not
        # warrant special consideration
        hooks.tokens['robot']['state']['gripper']['ambiguous_flag'] = False

        return next

    def realtime_execution(self, hooks):
        next = super(Initialize,self).realtime_execution(hooks)

        # Since we are initializing state, the ambigous movement is expected and does not
        # warrant special consideration
        hooks.tokens['robot']['state']['gripper']['ambiguous_flag'] = False

        return next

    '''
    Utility methods
    '''

    def resolve_to_hierarchical(self, arg_map):
        # arg_map = {
        #    '<skill-arg-uuid>': <actual_value>,
        #    ...
        # }
        
        unmapped_args = self._arguments.keys()
        primitives_copy = [p.to_dct() for p in self.primitives]

        for arg_uuid in arg_map.keys():
            if arg_uuid in self._arguments.keys():
                unmapped_args.remove(arg_uuid)

                value = arg_map[arg_uuid]
                key = self._arguments[arg_uuid].parameter_key
                temp = self._arguments[arg_uuid].temporary_value

                if key == 'machine_uuid': # need to perform expansion (this is not normal behavior)
                    template_prm = primitives_copy.pop(0) #machine_initialize
                    
                    mach_init_prims = []
                    for machine_uuid in value:
                        instance = dict(template_prm)
                        instance[key] = machine_uuid
                        instance['uuid'] = self._generate_uuid(MachineInitialize.full_type_string() + '-autogenerated-from-' + self.uuid)
                        instance['description'] = '(Autogenerated from list)'
                        mach_init_prims.append(instance)

                    primitives_copy = mach_init_prims + primitives_copy
                
                else:
                    for p in primitives_copy:
                        if key in p.keys() and p[key] == temp:
                            p[key] = value

        if len(unmapped_args) > 0:
            return None # could not resolve down to hierarchical node
        else:
            return Hierarchical.from_dct({
                'primitives': primitives_copy,
                'name': self.name,
                'type': Hierarchical.full_type_string(),
                'append_type': False,
                'editable': False,
                'deleteable': False,
                'description': '(Autogenerated hierarchical from skill) :: ' + self.description,
                'uuid': self._generate_uuid(Hierarchical.full_type_string() + '-autogenerated-from-' + self.uuid)})

